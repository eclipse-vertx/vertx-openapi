= Vert.x OpenAPI
:toc: left

Vert.x OpenAPI extends Vert.x to support https://www.openapis.org/[OpenAPI 3] in version 3.0 and 3.1.

Vert.x OpenAPI can:

* parse and validate your OpenAPI contract.
* parse and validate incoming requests according to your OpenAPI contract.
* parse and validate outgoing responses according to your OpenAPI contract.

== Using Vert.x OpenAPI

To use Vert.x OpenAPI, add the following dependency to the _dependencies_ section of your build descriptor:

* Maven (in your `pom.xml`):

[source,xml,subs="+attributes"]
----
<dependency>
  <groupId>io.vertx</groupId>
  <artifactId>vertx-openapi</artifactId>
  <version>${maven.version}</version>
</dependency>
----

* Gradle (in your `build.gradle` file):

[source,groovy,subs="+attributes"]
----
dependencies {
  compile 'io.vertx:vertx-openapi:${maven.version}'
}
----

== `OpenAPIContract`

When using Vert.x OpenAPI you always start with creating an instance of {@link io.vertx.openapi.contract.OpenAPIContract} from your contract.

[source,$lang]
----
{@link examples.ContractExamples#createContract}
----

NOTE: Due to security reasons this library is not downloading external references from your contract.
In case your contract requires external resources, they must be downloaded upfront and also provided to the
{@link io.vertx.openapi.contract.OpenAPIContract}.

The example below shows a snippet from an example OpenAPI contract that includes a reference to an external resource and how to create an instance of {@link io.vertx.openapi.contract.OpenAPIContract}.

[source,yaml]
----
paths:
  /pets:
    get:
      operationId: listPets
      parameters:
        - name: query
          schema:
            $ref: 'https://example.com/pet-components#/components/schemas/Query'
----

[source,$lang]
----
{@link examples.ContractExamples#createContractAdditionalFiles}
----

NOTE: During the instantiation of {@link io.vertx.openapi.contract.OpenAPIContract} the contract gets validated.
In case your contract does not match the OpenAPI specification or uses features which are not yet supported an error is thrown.

=== Path, Operation, Parameter

The {@link io.vertx.openapi.contract.OpenAPIContract} interface offers methods to navigate to the {@link io.vertx.openapi.contract.Path},
{@link io.vertx.openapi.contract.Operation} and {@link io.vertx.openapi.contract.Parameter} objects of the OpenAPI contract.

[source,$lang]
----
{@link examples.ContractExamples#pathParameterOperationExample}
----

=== Extensions

Vert.x OpenAPI supports the extension `x-vertx-openapi-urldecode` to specify if a `cookie` or `header` parameter should
be URL decoded. The default is `false`. `Query` parameters and `path` parameters gets always URL decoded.

[source,yaml]
----
paths:
  /forceEncoding:
    get:
      operationId: forceEncoding
      parameters:
        - in: header
          name: headerWithEncodedContent
          x-vertx-openapi-urldecode: true
          schema:
            type: string
----

== Validation

Vert.x OpenAPI checks both whether the content is syntactically correct and whether it corresponds to the schema.
If no schema is defined, or the content is binary no schema validation is performed.
Currently, only the following media types are supported:

* application/json
* application/json+hal
* application/octet-stream
* multipart/form-data

NOTE: It is planned to support more media types in the future.
It is also planned to support custom implementations of {@link io.vertx.openapi.validation.analyser.ContentAnalyser}, so that any media type can be validated.

=== Validation of Requests

The {@link io.vertx.openapi.validation.RequestValidator} offers multiple _validate_ methods to validate incoming requests.

[source,$lang]
----
{@link examples.ValidationExamples#createValidator}
----

The {@link io.vertx.openapi.validation.RequestValidator} also offers a signature of the _validate_ method that consumes a {@link io.vertx.openapi.validation.ValidatableRequest}.

[source,$lang]
----
{@link examples.ValidationExamples#validatableRequest}
----

NOTE: The parameters in a {@link io.vertx.openapi.validation.ValidatableRequest} must be stored in a specific format depending on the style, location and if they are exploded or not, otherwise the {@link io.vertx.openapi.validation.RequestValidator} can't validate the request.
The required format *MUST* exactly look like as described in the JavaDoc of {@link io.vertx.openapi.validation.RequestValidator}.

=== Validation of Responses

The {@link io.vertx.openapi.validation.ResponseValidator} offers a _validate_ method to validate responses. {@link io.vertx.openapi.validation.ValidatableResponse} offers multiple _create_ methods to build validatable responses easily.

In case that the validation of a response has passed, the returned {@link io.vertx.openapi.validation.ValidatedResponse} can directly be sent back to the client.

[source,$lang]
----
{@link examples.ValidationExamples#validatableResponse}
----

NOTE: The parameters in a {@link io.vertx.openapi.validation.ValidatableResponse} must be stored in a specific format depending on the style, location and if they are exploded or not, otherwise the {@link io.vertx.openapi.validation.ResponseValidator} can't validate the response.
The required format *MUST* exactly look like as described in the JavaDoc of {@link io.vertx.openapi.validation.ResponseValidator}.

=== Handle Validation Exceptions

A {@link io.vertx.openapi.validation.ValidatorException} is thrown, if the validation of a request or response fails.
The validation can fail for formal reasons, such as the wrong format for a parameter or the absence of a required parameter.
However, validation can of course also fail because the content does not match the defined schema.
In this case a {@link io.vertx.openapi.validation.SchemaValidationException} is thrown.
It is a subclass of _ValidatorException_ and provides access to the related {@link io.vertx.json.schema.OutputUnit} to allow further analysis of the error.

=== Support Custom Media Types

Custom media types that are currently not supported out of the box can be used by implementing a custom mapping of those
media type to JSON. This is done by creating a custom instance of a {@link io.vertx.openapi.validation.analyser.ContentAnalyserFactory}
and a corresponding {@link io.vertx.openapi.validation.analyser.ContentAnalyser} implementation.

In order to use those custom media types, they can be specified through
{@link io.vertx.openapi.contract.OpenAPIContractBuilder#registerSupportedMediaType}:

[source,$lang]
----
{@link examples.ContractExamples#customMediaTypes}
----

==== Unchecked (Opaque) Media Types

It is also possible to register a media type that will be handled as an opaque string instead of transforming them into
JSON by calling{@link io.vertx.openapi.contract.OpenAPIContractBuilder#registerUncheckedMediaType}:

[source,$lang]
----
{@link examples.ContractExamples#uncheckedMediaTypes}
----

NOTE: If you specify a schema for any unchecked media type in your OpenAPI contract, the request or response validator
built from that contract might still attempt schema validation, which will likely fail. To disable schema validation,
you can set the schema to be an unrestricted binary string (see below) or by omitting the schema altogether (only
allowed in OpenAPI 3.1)

[source,yaml]
----
paths:
  /sse:
    get:
      operationId: uncheckedMediaType
      responses:
        default:
          description: An SSE stream
          content:
            # OpenAPI 3.0 and 3.1: Unrestricted binary schema
            text/event-stream:
              schema:
                type: string
                format: binary
            # Only OpenAPI 3.1:
            # text/event-stream: {}
----
